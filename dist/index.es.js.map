{"version":3,"file":"index.es.js","sources":["../src/linkedList/getNextSiblings.ts","../src/linkedList/getChildItems.ts","../src/linkedList/getItemsBetween.ts","../src/linkedList/getNextItem.ts","../src/linkedList/getNextOrChildById.ts","../src/linkedList/getChildAndNextSiblingData.ts","../src/linkedList/upsertAndReturnRoot.ts","../src/linkedList/item.ts","../src/linkedList/validateList.ts","../src/linkedList/sortList.ts"],"sourcesContent":["import { Item } from \"./item\";\n\nexport function getNextSiblings<T extends Item<T, any>>(item: T): T[] {\n    if (item.nextItem) return [item.nextItem as T, ...getNextSiblings(item.nextItem) as T[]];\n    else return [];\n}","import { getNextSiblings } from \"./getNextSiblings\";\nimport { Item } from \"./item\";\n\n\nexport function getChildItems<T extends Item<T, any>>(item: T): T[] {\n    if (!item.firstChildItem) return [];\n    return [\n        item.firstChildItem as T,\n        ...getChildItems(item.firstChildItem) as T[],\n        ...getNextSiblings(item.firstChildItem).flatMap(x => [x as T, ...getChildItems<T>(x as T)])\n    ]\n}","import { Item } from \"./item\";\n\nfunction searchItems<T extends Item<T, any>>(item: T, end: T, ignoreChildren: boolean = false): T[] {\n    if (item == undefined) return [];\n    if (item.id == end.id) return [end];\n\n    const children = ignoreChildren ? [] : searchItems<T>(item.firstChildItem! as T, end);\n    if (children.slice(-1)[0]?.id == end.id) return [item, ...children];\n\n    if (item.nextItem) return [item, ...children, ...searchItems<T>(item.nextItem as T, end)];\n    if (item.parentItem) return [item, ...children, ...searchItems<T>(item.parentItem as T, end, true) as T[]].filter(x => x.id != item.parentItem!.id);\n\n    throw Error(\"Something went wrong. Please make sure that the start, and the end has a common parent\")\n\n}\n\n\nexport function getItemsBetween<T extends Item<T, any>>(start: T | undefined, end: T): T[] {\n    return searchItems(start!, end);\n}","import { Item } from \"./item\";\n\n/** The next block can either be the first child, the next sibling or the next sibling of a parent */\nexport function getNextItem<T extends Item<T, any>>(item: T): T | undefined {\n\n    if (item.firstChildItem) return item.firstChildItem as T;\n    if (item.nextItem) return item.nextItem as T;\n\n    function getParentNext(block: T): T | undefined {\n        if (block.nextItem) return block.nextItem as T;\n        if (block.parentItem) return getParentNext(block.parentItem as T);\n        return undefined;\n    }\n\n    return getParentNext(item)\n}","import { Item } from \"./item\";\n\nexport function getNextOrChildById<T extends Item<T, any>>(root: T, id: string): T | undefined {\n\n    function search(item: T): T | undefined {\n        if (item.id == id) return item;\n\n        let response: T | undefined;\n        if (item.firstChildItem) response ||= search(item.firstChildItem as T);\n        if (item.nextItem) response ||= search(item.nextItem as T);\n\n        return response;\n    }\n\n    return search(root)\n}","import { ItemData, ItemElement } from \"./item\";\n\nexport function getChildAndNextSiblingData<TData extends ItemData<any>, T extends ItemElement<any, T>>(item: T): TData[] {\n    if (!item) return [];\n\n    const response = [\n        item.getDetails() as TData\n    ];\n\n    if (item.firstChildItem) response.push(...getChildAndNextSiblingData<TData, T>(item.firstChildItem));\n    if (item.nextItem) response.push(...getChildAndNextSiblingData<TData, T>(item.nextItem));\n\n    return response;\n}","import { getNextOrChildById } from \"./getNextOrChildById\";\nimport { ActionableItem, ItemData } from \"./item\";\n\n\nexport function upsertAndReturnRoot<\n    TData,\n    TItemData extends ItemData<TData>,\n    TItem extends ActionableItem<TData, TItem>,\n>(\n    data: TItemData,\n    root: TItem | undefined,\n    createItem: (data: TItemData) => TItem\n): TItem {\n    if (root == undefined && (data.parentId || data.previousId)) {\n        throw new Error(\"the initial upsert must be the root window\");\n    }\n\n    type AItem = ActionableItem<TData, AItem>;\n    let item = root && getNextOrChildById(<AItem>root, data.id);\n\n    if (item == undefined\n        || item.parentItem?.id != data.parentId\n        || item.previousItem?.id != data.previousId\n    ) {\n        if (root && item && root.id == item.id) {\n            if (item!.firstChildItem) {\n                root = <TItem>item!.firstChildItem;\n            }\n            else if (item!.nextItem) root = <TItem>item!.nextItem;\n            else throw new Error(\"Failed to render block, a new rootBlock could not be determined\");\n        }\n\n        if (item == undefined) item = createItem(data)\n        item?.remove();\n\n\n        if (root == undefined) {\n            root = <TItem>item;\n        }\n        else if (data.previousId) {\n            const previous = getNextOrChildById(<AItem>root, data.previousId);\n            if (!previous) throw new Error(\"Failed to render item, previous item is not rendered\");\n\n            previous.after(item)\n        }\n        else if (data.parentId) {\n            const parent = getNextOrChildById(<AItem>root, data.parentId);\n            if (!parent) throw new Error(\"Failed to render item, parent item is not rendered\");\n\n            parent.append(item)\n        }\n        else {\n            root.before(<TItem>item);\n            root = <TItem>item;\n        }\n    }\n\n    item.update(data.data);\n\n    return root!;\n}","import { getNextSiblings } from \"./getNextSiblings\";\n\n\nexport interface Item<TItem, TData> {\n    get id(): string,\n    get parentItem(): TItem | undefined,\n    get firstChildItem(): TItem | undefined\n    get nextItem(): TItem | undefined,\n    get previousItem(): TItem | undefined\n    get data(): TData | undefined\n}\n\nexport interface ItemData<TData> {\n    id: string,\n    parentId?: string,\n    previousId?: string,\n    data: TData\n}\n\nexport interface ActionableItem<TData, TItem extends ActionableItem<TData, TItem>> extends Item<TItem, TData> {\n    update(data: TData): void;\n\n    /**\n     * Removes the item and all its children from both the linked list, and the doom render\n     */\n    remove(): void;\n\n    /**\n    * Inserts the item after the last child\n    */\n    append(item: TItem): void;\n\n    /**\n     * Inserts the item just before this item\n     */\n    before(item: TItem): void;\n\n    /**\n     * Inserts the item just after this item\n     */\n    after(item: TItem): void;\n}\n\n/** @internal */\nexport function render(...items: ItemData<any>[]): Item<any, any>[] {\n    const itemById = items.reduce((obj, curr) => {\n        obj[curr.id] = {\n            ...curr,\n            get parentItem() { return obj[curr.parentId!] },\n            get nextItem() { return obj[items.find(x => x.previousId == curr.id)?.id!] },\n            get previousItem() { return obj[curr.previousId!] },\n            get firstChildItem() { return obj[items.find(x => x.parentId == curr.id && x.previousId == undefined)?.id!] },\n            get data() { return curr.data },\n        };\n\n        return obj\n    }, {} as { [key: string]: Item<any, any> })\n\n    return items.map(x => itemById[x.id]);\n}\n\nexport abstract class ItemElement<TData, TItem extends ItemElement<TData, TItem>>\n    implements ActionableItem<TData, TItem> {\n\n    #id: string;\n    get id(): string { return this.#id; }\n\n    #parent: TItem | undefined;\n    get parentItem(): TItem | undefined { return this.#parent }\n    // set parentItem(item: TItem | undefined) { this.#parent = item; }\n\n    #firstChild: TItem | undefined;\n    get firstChildItem(): TItem | undefined { return this.#firstChild }\n    // set firstChildItem(item: TItem | undefined) { this.#firstChild = item; }\n\n    #next: TItem | undefined;\n    get nextItem(): TItem | undefined { return this.#next }\n    // set nextItem(item: TItem | undefined) { this.#next = item; }\n\n    #previous: TItem | undefined;\n    get previousItem(): TItem | undefined { return this.#previous }\n    // set previousItem(item: TItem | undefined) { this.#previous = item; }\n\n    abstract get data(): TData\n\n    abstract update(data: TData): void;\n    abstract render(data: TData): HTMLElement;\n\n    #target: HTMLElement\n    get target(): HTMLElement { return this.#target }\n\n    getDetails(): ItemData<TData> {\n        return {\n            id: this.id,\n            parentId: this.parentItem?.id,\n            previousId: this.previousItem?.id,\n            data: this.data\n        }\n    }\n\n    remove(): void {\n        if (this.parentItem?.firstChildItem?.id == this.id) {\n            this.parentItem.#firstChild = this.#next\n        }\n\n        if (this.previousItem) {\n            this.previousItem.#next = this.#next;\n        }\n        if (this.nextItem) {\n            this.nextItem.#previous = this.#previous;\n        }\n\n        this.#parent = undefined;\n        this.#next = undefined;\n        this.#previous = undefined;\n\n        this.#target.remove();\n    }\n\n    append(item: TItem): void {\n        if (item.id == this.id)\n            throw new Error(\"Cannot append item before itself\");\n\n        item.remove();\n\n        const children = this.firstChildItem && [this.firstChildItem, ...getNextSiblings(this.firstChildItem)];\n        const lastChild = children?.slice(-1)[0];\n\n        item.#parent = this as unknown as TItem;\n\n        if (lastChild) {\n            lastChild.after(item);\n        }\n        else {\n            this.#firstChild = item;\n            this.target.append(item.target);\n        }\n    }\n\n    before(item: TItem): void {\n        if (item.id == this.id)\n            throw new Error(\"Cannot append item before itself\");\n\n        item.remove();\n\n        item.#previous = this.previousItem\n        if (this.previousItem) this.previousItem.#next = item;\n        else if (this.parentItem) this.parentItem.#firstChild = item;\n\n        item.#parent = this.parentItem;\n        item.#next = this as unknown as TItem\n        this.#previous = item;\n\n        this.target.before(item.target);\n    }\n\n    after(item: TItem): void {\n        if (item.id == this.id)\n            throw new Error(\"Cannot append item before itself\");\n\n        item.remove();\n\n        item.#next = this.nextItem;\n        if (this.nextItem) this.nextItem.#previous = item;\n\n        item.#parent = this.parentItem;\n        item.#previous = this as unknown as TItem;\n        this.#next = item;\n\n        this.target.after(item.target);\n    }\n\n    constructor(id: string, data: TData) {\n        if ((id?.trim() ?? \"\").length == 0) throw new Error(\"id is not valid\");\n\n        this.#id = id\n\n        this.#target = this.render(data);\n    }\n}","import { ItemData } from \"./item\";\n\nfunction getLength(data: ItemData<any>[], parentId?: string, previousId?: string): number {\n    const block = data.find(x => x.parentId == parentId && x.previousId == previousId);\n    if (!block) return 0;\n\n    data = data.filter(x => x.id != block.id);\n\n    return 1\n        + getLength(data, block.id, undefined)\n        + getLength(data, parentId, block.id)\n}\n\n\nexport function validateList<T extends ItemData<any>>(items: T[]): void {\n    const rootBlocks = items.filter(x => x.parentId == undefined && x.previousId == undefined);\n\n    if (rootBlocks.length != 1 && items.length > 0)\n        throw new Error(\"Failed to determine the start of the linked list\");\n\n    const ids = items.map(x => x.id);\n    const idDuplicated = ids.some((x, i, a) => a.indexOf(x) != i);\n    if (idDuplicated)\n        throw new Error(\"Found duplicated instances of ids\");\n\n    const prevIds = items.map(x => x.previousId + \"_\" + x.parentId);\n    const prevIdDuplicated = prevIds.some((x, i, a) => a.indexOf(x) != i);\n    if (prevIdDuplicated)\n        throw new Error(\"Some of the items have the same previousId\");\n\n\n    if (getLength(items) != items.length) \n        throw new Error(\"Linked list is not valid\")\n}\n","import { ItemData } from \"./item\";\nimport { validateList } from \"./validateList\";\n\n\nfunction sort<T extends ItemData<any>>(items: T[], parentId: string | undefined, previousId: string | undefined) : T[]{\n    const item = items.find(x => x.parentId == parentId && x.previousId == previousId);\n    if (!item) return [];\n\n    items = items.filter(x => x.id != item.id);\n\n    return [\n        item,\n        ...sort(items, item.id, undefined),\n        ...sort(items, parentId, item.id)\n    ];\n}\n\nexport function sortList<T extends ItemData<any>>(items: T[]): T[] {\n    validateList(items);\n    return sort(items, undefined, undefined)\n}\n\n\n"],"names":["getNextSiblings","item","getChildItems","x","searchItems","end","ignoreChildren","_a","children","getItemsBetween","start","getNextItem","getParentNext","block","getNextOrChildById","root","id","search","response","getChildAndNextSiblingData","upsertAndReturnRoot","data","createItem","_b","previous","parent","_id","_parent","_firstChild","_next","_previous","_target","ItemElement","__privateAdd","__privateSet","__privateGet","lastChild","getLength","parentId","previousId","validateList","items","i","a","sort","sortList"],"mappings":"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"}